

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quick start &mdash;  v0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=683873e3"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Frequently asked questions" href="faq.html" />
    <link rel="prev" title="Features" href="features.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            
              <img src="../_static/cyt_logo_dark.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">System overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quick start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="#download">Download</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started-examples">Getting started examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-the-hardware">Building the hardware</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hardware-configuration">Hardware configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#build-process">Build process</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-the-driver">Building the driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-the-software">Building the software</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deploying-coyote">Deploying Coyote</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#eth-hacc">ETH HACC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#independent-set-up">Independent set-up</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently asked questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">System architecture</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../system/static.html">Static layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/dynamic.html">Dynamic layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/application.html">Application layer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">Developer Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html"></a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Quick start</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/intro/quick-start.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quick-start">
<h1>Quick start<a class="headerlink" href="#quick-start" title="Link to this heading"></a></h1>
<p>This is a brief introductory section outlining the steps to run Coyote and the essential prerequisites for its setup.</p>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading"></a></h2>
<p>Coyote system requirements:</p>
<ul>
<li><p>Software &amp; OS:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Linux</strong>: For the basic Coyote functionality, Linux &gt;= is sufficient. We have extensively tested Coyote with Linux 5.4, Linux 5.15, Linux 6.2 and Linux 6.8.</p></li>
<li><p><strong>CMake</strong>: <em>CMake</em> &gt;= 3.5 with support for <em>C++17</em></p></li>
<li><p><strong>Vivado/Vitis</strong>: Coyote has to be built with the full Vivado suite, including Vitis HLS. Coyote supports Vivado/Vitis HLS &gt;= 2022.1. We have conducted extensive testing with Vivado 2022.1 and recommend this version for synthesizing Coyote (but others should work as well).
All network-related Coyote configurations are built using the UltraScale+ Integrated 100G Ethernet Subsystem, for which a valid license must be obtained.</p></li>
<li><p><strong>Hugepages enabled</strong></p></li>
<li><p><strong>Additional information</strong>: For GPU peer-to-peer (P2P) support, Linux &gt;= 6.2 is required with AMD ROCm &gt;= 6.0.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Hardware:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>FPGA</strong>: The main target platform for the current Coyote release is the AMD Alveo U55C accelerator card. Some support and testing exists for the older U250 and U280 platforms.</p></li>
<li><p><strong>GPU</strong>: For GPU peer-to-peer (P2P) support, Coyote currently supports AMD Instinct Accelerator cards. We extensively tested P2P functionality on AMD Instinc MI100 and MI210.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="download">
<h2>Download<a class="headerlink" href="#download" title="Link to this heading"></a></h2>
<p>To get started with Coyote, cloning the repository making sure to check out all the submodules:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>--recurse-submodules<span class="w"> </span>https://github.com/fpgasystems/Coyote
</pre></div>
</div>
</section>
<section id="getting-started-examples">
<h2>Getting started examples<a class="headerlink" href="#getting-started-examples" title="Link to this heading"></a></h2>
<p>Coyote currently includes eight getting started examples, found in <strong>Coyote/examples</strong>, covering the following concepts:</p>
<p><strong>Example 1: Static HW design &amp; data movement initiated by the CPU</strong>: How to synthesize the Coyote hardware, as well as the various configurations and flags. On the software side, concepts such as data movement and Coyote threads are covered, which enable easy integration from a high-level language (C++) with the FPGA.</p>
<p><strong>Example 2: HLS Vector Addition</strong>: How to deploy high-level synthesis (HLS) kernels with Coyote, enable multiple data streams and how to use the shell build flow for faster synthesis.</p>
<p><strong>Example 3: Multi-threaded AES encryption</strong>: How to set control registers on the FPGA in C++ and how to improve performance by re-using the same hardware with multiple software threads.</p>
<p><strong>Example 4: User interrupts</strong>: How to issue interrupts from hardware and pick them up in host software.</p>
<p><strong>Example 5: Shell reconfiguration</strong>: How to perform run-time reconfiguration of the Coyote shell, enabling the swapping out of various services (networking stack, memory type, user application etc.)</p>
<p><strong>Example 6: FPGA-GPU peer-to-peer (P2P) data movement</strong>: How to enable interaction of the FPGA with a GPU, completely bypassing host memory when performing data movement. A particularly interesting example for building heteregenous ML systems.</p>
<p><strong>Example 7: Data movement initiated by the FPGA</strong>: How to perform data movement using the FPGA, independently from the CPU, by using Coyote’s internal send and completion queues.</p>
<p><strong>Example 8: Using the FPGA as a SmartNIC for Remote Direct Memory Access</strong>: How to do networking with Coyote’s internal, 100G, fully RoCEv2-compliant networking stack.</p>
<p>Be sure to check out the accompanying README.md, in <strong>Coyote/examples</strong>, to get started with these examples and deploy them on your FPGA set-up.</p>
</section>
<section id="building-the-hardware">
<h2>Building the hardware<a class="headerlink" href="#building-the-hardware" title="Link to this heading"></a></h2>
<section id="hardware-configuration">
<h3>Hardware configuration<a class="headerlink" href="#hardware-configuration" title="Link to this heading"></a></h3>
<p>Coyote uses <em>CMake</em> with Vivado to synthesize the target hardware.
This flow provides the capability to synthesize individual application projects, that are loaded in different virtual FPGAs (vFPGAs), independently and subsequently merge them into a single overarching project.
This is the basis for the <strong>nested synthesis</strong> in Coyote.
The following layers, each represented by an independent Vivado project, exist:</p>
<ol class="arabic">
<li><p><strong>Static layer</strong>: This is the static portion of the system. It is always the same for every project (for the same chip). It provides the bare essential functionality to support the rest of the system, including data movement and interaction with the host CPU.</p></li>
<li><p><strong>Dynamic layer</strong>: This layer holds all the services (networking, memory etc.) offered by Coyote which are shared among all applications. It is the first dynamic layer that can be swapped during runtime and represents the current shell configuration.</p></li>
<li><p><strong>Application layer</strong>: This layer holds user projects, each representing a separate user application. The number of overall projects depends on two factors:</p>
<blockquote>
<div><ul class="simple">
<li><p>The number of virtual FPGAs (vFPGAs) within the dynamic layer (<code class="docutils literal notranslate"><span class="pre">N_REGIONS</span></code>), and</p></li>
<li><p>The number of different configurations of these vFPGAs in the overarching shell (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span></code>).</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>To build the hardware, one should provide a configuration via <em>CMake</em>. The following is an example project configuration:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.5</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">example_prj</span><span class="p">)</span>

<span class="w"> </span><span class="c"># Path to Coyote directory</span>
<span class="nb">set</span><span class="p">(</span><span class="s">CYT_DIR</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/</span><span class="p">)</span>

<span class="c"># Path to Coyote&#39;s internal CMake, which defines the custom build targets</span>
<span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_MODULE_PATH</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_MODULE_PATH</span><span class="o">}</span><span class="w"> </span><span class="o">${</span><span class="nv">CYT_DIR</span><span class="o">}</span><span class="s">/cmake</span><span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span><span class="s">CoyoteHW</span><span class="w"> </span><span class="s">REQUIRED</span><span class="p">)</span>

<span class="c"># Shell configuration</span>
<span class="nb">set</span><span class="p">(</span><span class="s">FDEV_NAME</span><span class="w"> </span><span class="s2">&quot;u55c&quot;</span><span class="p">)</span><span class="w">   </span><span class="c"># Compile for Alveo U55C</span>
<span class="nb">set</span><span class="p">(</span><span class="s">N_REGIONS</span><span class="w"> </span><span class="s">2</span><span class="p">)</span><span class="w">        </span><span class="c"># Number of vFPGAs in this specific shell</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_PR</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w">            </span><span class="c"># Enable partial reconfiguration</span>
<span class="nb">set</span><span class="p">(</span><span class="s">N_CONFIG</span><span class="w"> </span><span class="s">2</span><span class="p">)</span><span class="w">         </span><span class="c"># Number of PR configurations</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_STRM</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w">          </span><span class="c"># Interface to host memory</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_MEM</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w">           </span><span class="c"># Interface to FPGA (HBM/DRAM)</span>

<span class="c"># Validate the configuration</span>
<span class="nb">validation_checks_hw</span><span class="p">()</span>

<span class="c"># Load arbitrary user applications for all configs</span>
<span class="nb">load_apps</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">VFPGA_C0_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/vector_add&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C0_1</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/shifter&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C1_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/neural_network&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C1_1</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/hyper_log_log&quot;</span>
<span class="p">)</span>

<span class="c"># Generate all targets</span>
<span class="nb">create_hw</span><span class="p">()</span>
</pre></div>
</div>
<p>Since the static part never changes and is not configurable, Coyote provides a pre-routed and locked static layer checkpoint which is used for linking.
In this example, Coyote will link to the existing static design floorplanned for the Alveo U55C chip with the above shell configuration.</p>
<p>After indicating the path to Coyote repository, the shell configuration is chosen. In this example, we enable two distinct vFPGAs.
Each of these functions as an <em>independent hardware process</em>, accommodating one user application (<em>user process</em>) at a time.
Applications in these vFPGAs can also be swapped during runtime without disrupting the surrounding shell operations (<code class="docutils literal notranslate"><span class="pre">EN_PR</span></code> flag).
Multiple dynamic configurations can be compiled within one project (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span></code>).
Additional flags can then be provided. All these will define the exact configuration of the shell.
Be sure to include the <code class="docutils literal notranslate"><span class="pre">validation_checks_hw()</span></code> and <code class="docutils literal notranslate"><span class="pre">create_hw()</span></code> functions, necessary for properly setting up the environment.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> function facilitates the automatic loading of user hardware applications into the corresponding vFPGAs.
This process also performs any essential high-level synthesis compilations, if needed.
When utilized, users must explicitly provide path to all configurations (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span> <span class="pre">x</span> <span class="pre">N_REGIONS</span></code>).
The hardware applications (in the provided path) should be structured as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>├<span class="w"> </span>CMakeLists.txt
└<span class="w"> </span>&lt;PATH-TO-YOUR-HARDWARE-PROJECT&gt;
<span class="w">    </span>├<span class="w"> </span>vfpga_top.svh
<span class="w">    </span>├<span class="w"> </span>init_ip.tcl
<span class="w">    </span>└<span class="w"> </span>hls
<span class="w">        </span>├<span class="w"> </span>kernel_1
<span class="w">            </span>└<span class="w"> </span>kernel_1.cpp
<span class="w">            </span>└<span class="w"> </span>other_files.cpp
<span class="w">        </span>├<span class="w"> </span>kernel_2
<span class="w">            </span>└<span class="w"> </span>kernel_2.cpp
<span class="w">            </span>└<span class="w"> </span>other_files.cpp
<span class="w">    </span>└<span class="w"> </span>hdl
<span class="w">        </span>└<span class="w"> </span>all<span class="w"> </span>RTL<span class="w"> </span>cores<span class="w"> </span>and<span class="w"> </span>files<span class="w"> </span>that<span class="w"> </span>might<span class="w"> </span>be<span class="w"> </span>used<span class="w"> </span><span class="o">(</span>.v,<span class="w"> </span>.sv,<span class="w"> </span>.svh,<span class="w"> </span>.vhd,<span class="w"> </span>...<span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure to create the <code class="docutils literal notranslate"><span class="pre">vfpga_top.svh</span></code>. This is the main integration header file. It is used to connect your circuits to the interfaces exposed by each vFPGA.</p>
</div>
<p>It is not necessary to use the <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> function. You can also integrate your circuits manually into the provided wrappers (available after the project creation step).</p>
</section>
<section id="build-process">
<h3>Build process<a class="headerlink" href="#build-process" title="Link to this heading"></a></h3>
<p>The projects can be built after configuration and directories have been setup. First, the build directory can be created:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>build_hw<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_hw
</pre></div>
</div>
<p>The <em>CMake</em> configuration can then be invoked:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake<span class="w"> </span>&lt;path-to-cmake-config&gt;<span class="w"> </span>&lt;additional-flags&gt;
</pre></div>
</div>
<p>If all validation checks pass without errors, all the necessary build files will be generated after this step.
Project creation can be then be invoked with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Performs code generation, since source files are parameterized</span>
<span class="c1"># Additionally, performs HLS compilation</span>
make<span class="w"> </span>project
</pre></div>
</div>
<p>This will create the following projects:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Static layer, only if (BUILD_STATIC = 1)</span>
&lt;project_name&gt;_static

<span class="c1"># Dynamic layer</span>
&lt;project_name&gt;_shell

<span class="c1"># Application layer</span>
&lt;project_name&gt;_config_0/&lt;project_name&gt;_user_c0_0<span class="w">    </span><span class="c1"># (vFPGA_C0_0)</span>
&lt;project_name&gt;_config_0/&lt;project_name&gt;_user_c0_1<span class="w">    </span><span class="c1"># (vFPGA_C0_1)</span>
...
&lt;project_name&gt;_config_1/&lt;project_name&gt;_user_c1_0<span class="w">    </span><span class="c1"># (vFPGA_C1_0)</span>
...
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> was used, there is nothing else that users need to do after this command.
Otherwise each of the user projects (<code class="docutils literal notranslate"><span class="pre">vFPGA_CX_Y</span></code>) will contain wrappers under the <em>project/hdl</em> directory where
users can instantiate their circuits as they please.</p>
<p>Compilation can then be executed.
To generate all bitstreams straight away, one can run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make<span class="w"> </span>bitgen
</pre></div>
</div>
<p>The command consists of the following incremental steps:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Synthesize all layers (1x dynamic, N_REGIONS x N_CONFIG app and 1x static, if BUILD_STATIC = 1)</span>
make<span class="w"> </span>synth

<span class="c1"># Link the layers (static + dynamic + app) into a single Vivado project</span>
make<span class="w"> </span>link

<span class="c1"># Place and route the linked shell (all three layers)</span>
make<span class="w"> </span>shell

<span class="c1"># Compile the application layer (only if EN_PR is enabled)</span>
make<span class="w"> </span>app

<span class="c1"># Generate bitstreams</span>
make<span class="w"> </span>bitgen
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">EN_PR</span> <span class="pre">=</span> <span class="pre">1</span></code> floor-planning of the applications (vFPGAs) needs to be done by users explicitly after the <em>make shell</em> step.
This can be done by opening the generated <code class="docutils literal notranslate"><span class="pre">shell_subdivided.dcp</span></code> checkpoint.
Check out the following link for a detailed <a class="reference external" href="https://docs.amd.com/r/en-US/ug903-vivado-using-constraints/Floorplanning">floor-planning guide</a>.
Alternatively, users can provide pre-existing vFPGA floor-plan via the <code class="docutils literal notranslate"><span class="pre">FPLAN_PATH</span></code> variable during configuration.</p>
<p>Once the (typically quite lengthy) compilation is done, the bitstreams will be generated for each application and configuration.
The shell bitstream (<em>the dynamic layer bitstream</em>) with the initial (config 0) configuration will also be generated.
This one can be used to load the shell dynamically and swap out other shells during runtime.
All of these will be present in the <cite>bitstreams</cite> directory.</p>
<figure class="align-default" id="build-struct">
<img alt="../_images/build_struct.png" src="../_images/build_struct.png" />
</figure>
<p>The overall bitstream structure should roughly resemble the one in the figure above.</p>
</section>
</section>
<section id="building-the-driver">
<h2>Building the driver<a class="headerlink" href="#building-the-driver" title="Link to this heading"></a></h2>
<p>The driver can be built by running make within the driver directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>driver<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure to compile the driver on the target deployment machine.</p>
</div>
</section>
<section id="building-the-software">
<h2>Building the software<a class="headerlink" href="#building-the-software" title="Link to this heading"></a></h2>
<p>Procedure to build the software is similar to the one for hardware, albeit more simple.
Again, software build use CMake for compiling the software. For examples of CMakeLists.txt for software builds, refer to <strong>Coyote/examples</strong>.</p>
<p>The steps remain the same as for the hardware build:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>build_sw<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_sw
cmake<span class="w"> </span>&lt;path-to-cmake-config&gt;<span class="w"> </span>&lt;additional-flags&gt;
make
</pre></div>
</div>
</section>
<section id="deploying-coyote">
<h2>Deploying Coyote<a class="headerlink" href="#deploying-coyote" title="Link to this heading"></a></h2>
<p>We cover how to deploy the examples in two set-ups: The Heterogeneous Accelerated Compute Cluster (HACC) at ETH Zurich and on a independent set-up.</p>
<section id="eth-hacc">
<h3>ETH HACC<a class="headerlink" href="#eth-hacc" title="Link to this heading"></a></h3>
<p>The Heterogeneous Accelerated Compute Clusters (HACC) program is a special initiative to support novel research in adaptive compute acceleration.
The scope of the program is broad and encompasses systems, architecture, tools and applications.
You can check out HACC in more details at: <a class="reference external" href="https://www.amd-haccs.io/">amd-haccs</a>.</p>
<p>The ETH HACC provides the ideal environment to run Coyote examples,
since users can book various compute nodes (Alveo U55C, V80, U250, U280, Instinct GPU etc.)
which are connected via a high-speed (100G) network.</p>
<figure class="align-default">
<img alt="../_images/hacc.png" src="../_images/hacc.png" />
</figure>
<p>The interaction and deployment of Coyote on the HACC cluster can be simplified by using the <code class="docutils literal notranslate"><span class="pre">hdev</span></code> tool.
It also allows to easily program the FPGA with a Coyote bitstream and insert the driver.
For this purpose, the script <code class="docutils literal notranslate"><span class="pre">util/program_hacc_local.sh</span></code> has been created:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>bash<span class="w"> </span>util/program_hacc_local.sh<span class="w"> </span>&lt;path-to-bitstream&gt;<span class="w"> </span>&lt;path-to-driver-ko&gt;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bitstreams with <code class="docutils literal notranslate"><span class="pre">.bin</span></code> extensions should be used when loading the designs dynamically through Coyote. If bitstreams are being programmed through Vivado programmer, use the ones with <code class="docutils literal notranslate"><span class="pre">.bit</span></code> extension.</p>
</div>
<p>A successful completion of the FPGA programming and driver insertion can be checked via a call to:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>dmesg
</pre></div>
</div>
<p>If the driver insertion and bitstream programming went correctly through, the last printed message should be <code class="docutils literal notranslate"><span class="pre">probe</span> <span class="pre">returning</span> <span class="pre">0</span></code>.
If you see this, your system is all ready to run the accompanying Coyote software.</p>
</section>
<section id="independent-set-up">
<h3>Independent set-up<a class="headerlink" href="#independent-set-up" title="Link to this heading"></a></h3>
<p>The steps to follow when deploying Coyote on an independent set-up are:</p>
<ol class="arabic simple">
<li><p>Program the FPGA using the synthesized bitstream using Vivado Hardware Manager via the GUI or a custom script (an example structure is given in <code class="docutils literal notranslate"><span class="pre">util/program_alveo.tcl</span></code>).</p></li>
<li><p>Rescan the PCIe devices; an example script of this is given <code class="docutils literal notranslate"><span class="pre">util/hot_reset.sh</span></code>. It may require some tuning for your system.</p></li>
<li><p>Insert the driver using (the parameters IP and MAC must only be specified when using networking on the FPGA):</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>insmod<span class="w"> </span>Coyote/driver/coyote_driver.ko<span class="w"> </span><span class="nv">ip_addr</span><span class="o">=</span><span class="nv">$qsfp_ip</span><span class="w"> </span><span class="nv">mac_addr</span><span class="o">=</span><span class="nv">$qsfp_mac</span><span class="w"> </span><span class="o">(</span><span class="p">;</span><span class="w"> </span>i.e.<span class="w"> </span>Example<span class="w"> </span><span class="m">8</span><span class="o">)</span>
</pre></div>
</div>
<p>A successful completion of the FPGA programming and driver insertion can be checked via a call to:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>dmesg
</pre></div>
</div>
<p>If the driver insertion and bitstream programming went correctly through, the last printed message should be <code class="docutils literal notranslate"><span class="pre">probe</span> <span class="pre">returning</span> <span class="pre">0</span></code>.
If you see this, your system is all ready to run the accompanying Coyote software.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="Features" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="faq.html" class="btn btn-neutral float-right" title="Frequently asked questions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Systems Group, ETH Zurich (2025).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>