

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quick start &mdash; Coyote v0.2.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=cc40f7fa"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Frequently asked questions" href="faq.html" />
    <link rel="prev" title="Features" href="features.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Coyote
              <img src="../_static/cyt_logo_dark.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">System overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quick start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="#download">Download</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started-examples">Getting started examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-the-hardware">Building the hardware</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hardware-configuration">Hardware configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#build-process">Build process</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-the-driver">Building the driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-the-software">Building the software</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deploying-coyote">Deploying Coyote</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#eth-hacc">ETH HACC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#independent-set-up">Independent set-up</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#simulating-vfpgas">Simulating vFPGAs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="publications.html">Citation and publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">Release notes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">Developer Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/sw.html">Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/driver.html">Device driver</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coyote</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Quick start</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/intro/quick-start.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quick-start">
<h1>Quick start<a class="headerlink" href="#quick-start" title="Link to this heading"></a></h1>
<p>This is a brief introductory section outlining the steps to run Coyote and the essential prerequisites for its setup.</p>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading"></a></h2>
<p>Coyote system requirements:</p>
<ul>
<li><p>Software &amp; OS:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Linux</strong>: For the basic Coyote functionality, Linux &gt;= 5 is sufficient. We have extensively tested Coyote with Linux 5.4, Linux 5.15, Linux 6.2 and Linux 6.8.</p></li>
<li><p><strong>CMake</strong>: <em>CMake</em> &gt;= 3.5 with support for <em>C++17</em></p></li>
<li><p><strong>Vivado/Vitis</strong>: Coyote has to be built with the full Vivado suite, including Vitis HLS. Coyote supports Vivado/Vitis HLS &gt;= 2022.1. We have conducted extensive testing with Vivado 2024.1 and 2022.1, though other versions should work as well.
All network-related Coyote configurations are built using the UltraScale+ Integrated 100G Ethernet Subsystem, for which a valid license must be obtained.</p></li>
<li><p><strong>Hugepages enabled</strong></p></li>
<li><p><strong>Additional information</strong>: For GPU peer-to-peer (P2P) support, Linux &gt;= 6.2 is required with AMD ROCm &gt;= 6.0. If using Coyote’s Python run-time, pyCoyote, Python &gt;= 3.8 is required with pip installed.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Hardware:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>FPGA</strong>: The main target platform for the current Coyote release is the AMD Alveo U55C accelerator card. We also include suppport for the AMD Alveo U250 and U280 accelerator cards.</p></li>
<li><p><strong>GPU</strong>: For GPU peer-to-peer (P2P) support, Coyote currently supports AMD Instinct Accelerator cards. We extensively tested P2P functionality on AMD Instinc MI100 and MI210.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="download">
<h2>Download<a class="headerlink" href="#download" title="Link to this heading"></a></h2>
<p>To get started with Coyote, cloning the repository making sure to check out all the submodules:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>--recurse-submodules<span class="w"> </span>https://github.com/fpgasystems/Coyote
</pre></div>
</div>
</section>
<section id="getting-started-examples">
<h2>Getting started examples<a class="headerlink" href="#getting-started-examples" title="Link to this heading"></a></h2>
<p>Coyote currently includes ten examples, covering the following concepts:</p>
<p><strong>Example 1: Hello World!:</strong> How to synthesize the Coyote hardware, as well as the various configurations and flags. On the software side, concepts such as data movement and <em>Coyote threads</em> are covered, which enable easy integration from a high-level language (C++) with the FPGA.</p>
<p><strong>Example 2: HLS vector addition:</strong> How to deploy high-level synthesis (HLS) kernels with Coyote and enable multiple data streams at once.</p>
<p><strong>Example 3: Multiple, parallel AES encryption blocks:</strong> How to set control registers on the FPGA from C++ and deploy multiple, parallel and indendent applications (vFPGAs) on hardware.</p>
<p><strong>Example 4: User interrupts:</strong> How to issue interrupts from hardware and pick them up in host software.</p>
<p><strong>Example 5: Shell reconfiguration:</strong> How to perform run-time reconfiguration of the Coyote shell, enabling the swapping out of various services (networking stack, memory type, user application etc.)</p>
<p><strong>Example 6: FPGA-GPU peer-to-peer (P2P) data movement:</strong> How to enable interaction of the FPGA with a GPU, completely bypassing host memory when performing data movement. A particularly interesting example for building heterogeneous ML systems.</p>
<p><strong>Example 7: Data movement initiated by the FPGA:</strong> How to perform data movement using the FPGA, independently from the CPU, by using Coyote’s internal <em>send</em> and <em>completion</em> queues.</p>
<p><strong>Example 8: Multi-threaded AES encryption [ADVANCED]:</strong> How to improve performance by re-using the same hardware with multiple software threads.</p>
<p><strong>Example 9: Using the FPGA as a SmartNIC for Remote Direct Memory Access:</strong> How to do networking with Coyote’s internal, 100G, fully RoCEv2-compliant networking stack.</p>
<p><strong>Example 10: Application reconfiguration and background services [ADVANCED]:</strong> How to dynamically load Coyote applications to a system-wide service, which automatically schedules tasks and reconfigures the FPGA with the corrects bitstream, based on client requests.</p>
<p>Be sure to check out the accompanying README.md, in <strong>Coyote/examples</strong>, to get started with these examples and deploy them on your FPGA set-up.</p>
<p>The above-mentioned examples include software examples in C++ as well as hardware examples in HLS and RTL. However, Coyote can also be used with Python via the pyCoyote library.
The same examples, implement with Python instead of C++, can be found in the <a class="reference external" href="https://github.com/fpgasystems/pyCoyote">pyCoyote repository</a>.</p>
</section>
<section id="building-the-hardware">
<h2>Building the hardware<a class="headerlink" href="#building-the-hardware" title="Link to this heading"></a></h2>
<section id="hardware-configuration">
<h3>Hardware configuration<a class="headerlink" href="#hardware-configuration" title="Link to this heading"></a></h3>
<p>Coyote uses <em>CMake</em> with Vivado to synthesize the target hardware.
This flow provides the capability to synthesize individual application projects, that are loaded in different virtual FPGAs (vFPGAs), independently and subsequently merge them into a single overarching project.
This is the basis for the <strong>nested synthesis</strong> in Coyote.
The following layers, each represented by an independent Vivado project, exist:</p>
<ol class="arabic">
<li><p><strong>Static layer</strong>: This is the static portion of the system. It is always the same for every project (for the same chip). It provides the bare essential functionality to support the rest of the system, including data movement and interaction with the host CPU.</p></li>
<li><p><strong>Dynamic layer</strong>: This layer holds all the services (networking, memory etc.) offered by Coyote which are shared among all applications. It is the first dynamic layer that can be swapped during runtime and represents the current shell configuration.</p></li>
<li><p><strong>Application layer</strong>: This layer holds user projects, each representing a separate user application. The number of overall projects depends on two factors:</p>
<blockquote>
<div><ul class="simple">
<li><p>The number of virtual FPGAs (vFPGAs) within the dynamic layer (<code class="docutils literal notranslate"><span class="pre">N_REGIONS</span></code>), and</p></li>
<li><p>The number of different configurations of these vFPGAs in the overarching shell (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span></code>).</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>To build the hardware, one should provide a configuration via <em>CMake</em>. The following is an example project configuration:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.5</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">example_prj</span><span class="p">)</span>

<span class="w"> </span><span class="c"># Path to Coyote directory</span>
<span class="nb">set</span><span class="p">(</span><span class="s">CYT_DIR</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/</span><span class="p">)</span>

<span class="c"># Path to Coyote&#39;s internal CMake, which defines the custom build targets</span>
<span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_MODULE_PATH</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_MODULE_PATH</span><span class="o">}</span><span class="w"> </span><span class="o">${</span><span class="nv">CYT_DIR</span><span class="o">}</span><span class="s">/cmake</span><span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span><span class="s">CoyoteHW</span><span class="w"> </span><span class="s">REQUIRED</span><span class="p">)</span>

<span class="c"># Shell configuration</span>
<span class="nb">set</span><span class="p">(</span><span class="s">FDEV_NAME</span><span class="w"> </span><span class="s2">&quot;u55c&quot;</span><span class="p">)</span><span class="w">   </span><span class="c"># Compile for Alveo U55C</span>
<span class="nb">set</span><span class="p">(</span><span class="s">N_REGIONS</span><span class="w"> </span><span class="s">2</span><span class="p">)</span><span class="w">        </span><span class="c"># Number of vFPGAs in this specific shell</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_PR</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w">            </span><span class="c"># Enable partial reconfiguration</span>
<span class="nb">set</span><span class="p">(</span><span class="s">N_CONFIG</span><span class="w"> </span><span class="s">2</span><span class="p">)</span><span class="w">         </span><span class="c"># Number of PR configurations</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_STRM</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w">          </span><span class="c"># Interface to host memory</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_MEM</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w">           </span><span class="c"># Interface to FPGA (HBM/DRAM)</span>

<span class="c"># Validate the configuration</span>
<span class="nb">validation_checks_hw</span><span class="p">()</span>

<span class="c"># Load arbitrary user applications for all configs</span>
<span class="nb">load_apps</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">VFPGA_C0_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/vector_add&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C0_1</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/shifter&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C1_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/neural_network&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C1_1</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/hyper_log_log &lt;some_path_to_a_library&gt;/library&quot;</span>
<span class="p">)</span>

<span class="c"># Generate all targets</span>
<span class="nb">create_hw</span><span class="p">()</span>
</pre></div>
</div>
<p>Since the static part never changes and is not configurable, Coyote provides a pre-routed and locked static layer checkpoint which is used for linking.
In this example, Coyote will link to the existing static design floorplanned for the Alveo U55C chip with the above shell configuration.</p>
<p>After indicating the path to Coyote repository, the shell configuration is chosen. In this example, we enable two distinct vFPGAs.
Each of these functions as an <em>independent hardware process</em>, accommodating one user application (<em>user process</em>) at a time.
Applications in these vFPGAs can also be swapped during runtime without disrupting the surrounding shell operations (<code class="docutils literal notranslate"><span class="pre">EN_PR</span></code> flag).
Multiple dynamic configurations can be compiled within one project (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span></code>).
Additional flags can then be provided. All these will define the exact configuration of the shell.
Be sure to include the <code class="docutils literal notranslate"><span class="pre">validation_checks_hw()</span></code> and <code class="docutils literal notranslate"><span class="pre">create_hw()</span></code> functions, necessary for properly setting up the environment.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> function facilitates the automatic loading of user hardware applications into the corresponding vFPGAs.
This process also performs any essential high-level synthesis compilations, if needed.
When utilized, users must explicitly provide path to all configurations (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span> <span class="pre">x</span> <span class="pre">N_REGIONS</span></code>).
The hardware applications (in the provided path) should be structured as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>├<span class="w"> </span>CMakeLists.txt
└<span class="w"> </span>&lt;PATH-TO-YOUR-HARDWARE-PROJECT&gt;
<span class="w">    </span>├<span class="w"> </span>vfpga_top.svh
<span class="w">    </span>├<span class="w"> </span>init_ip.tcl
<span class="w">    </span>└<span class="w"> </span>hls
<span class="w">        </span>├<span class="w"> </span>kernel_1
<span class="w">            </span>└<span class="w"> </span>kernel_1.cpp
<span class="w">            </span>└<span class="w"> </span>other_files.cpp
<span class="w">        </span>├<span class="w"> </span>kernel_2
<span class="w">            </span>└<span class="w"> </span>kernel_2.cpp
<span class="w">            </span>└<span class="w"> </span>other_files.cpp
<span class="w">    </span>└<span class="w"> </span>hdl
<span class="w">        </span>└<span class="w"> </span>all<span class="w"> </span>RTL<span class="w"> </span>cores<span class="w"> </span>and<span class="w"> </span>files<span class="w"> </span>that<span class="w"> </span>might<span class="w"> </span>be<span class="w"> </span>used<span class="w"> </span><span class="o">(</span>.v,<span class="w"> </span>.sv,<span class="w"> </span>.svh,<span class="w"> </span>.vhd,<span class="w"> </span>...<span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure to create the <code class="docutils literal notranslate"><span class="pre">vfpga_top.svh</span></code>. This is the main integration header file. It is used to connect your circuits to the interfaces exposed by each vFPGA.</p>
</div>
<p>If you want to use hardware libraries as shared code in a vFPGA configuration from other folders, you can add them to the configuration as shown for <code class="docutils literal notranslate"><span class="pre">VFGPA_C1_1</span></code>. The library folder is assumed to have the same folder structure as the base source folder of the vFPGA config. However, only the base source folder has to have a <code class="docutils literal notranslate"><span class="pre">vfpga_top.svh</span></code> file.</p>
<p>It is not necessary to use the <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> function. You can also integrate your circuits manually into the provided wrappers (available after the project creation step).</p>
</section>
<section id="build-process">
<h3>Build process<a class="headerlink" href="#build-process" title="Link to this heading"></a></h3>
<p>The projects can be built after configuration and directories have been setup. First, the build directory can be created:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>build_hw<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_hw
</pre></div>
</div>
<p>The <em>CMake</em> configuration can then be invoked:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake<span class="w"> </span>&lt;path-to-cmake-config&gt;<span class="w"> </span>&lt;additional-flags&gt;
</pre></div>
</div>
<p>If all validation checks pass without errors, all the necessary build files will be generated after this step.
Project creation can be then be invoked with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Performs code generation, since source files are parameterized</span>
<span class="c1"># Additionally, performs HLS compilation</span>
make<span class="w"> </span>project
</pre></div>
</div>
<p>This will create the following projects:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Static layer, only if (BUILD_STATIC = 1)</span>
&lt;project_name&gt;_static

<span class="c1"># Dynamic layer</span>
&lt;project_name&gt;_shell

<span class="c1"># Application layer</span>
&lt;project_name&gt;_config_0/&lt;project_name&gt;_user_c0_0<span class="w">    </span><span class="c1"># (vFPGA_C0_0)</span>
&lt;project_name&gt;_config_0/&lt;project_name&gt;_user_c0_1<span class="w">    </span><span class="c1"># (vFPGA_C0_1)</span>
...
&lt;project_name&gt;_config_1/&lt;project_name&gt;_user_c1_0<span class="w">    </span><span class="c1"># (vFPGA_C1_0)</span>
...
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> was used, there is nothing else that users need to do after this command.
Otherwise each of the user projects (<code class="docutils literal notranslate"><span class="pre">vFPGA_CX_Y</span></code>) will contain wrappers under the <em>project/hdl</em> directory where
users can instantiate their circuits as they please.</p>
<p>Compilation can then be executed.
To generate all bitstreams straight away, one can run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make<span class="w"> </span>bitgen
</pre></div>
</div>
<p>The command consists of the following incremental steps:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Synthesize all layers (1x dynamic, N_REGIONS x N_CONFIG app and 1x static, if BUILD_STATIC = 1)</span>
make<span class="w"> </span>synth

<span class="c1"># Link the layers (static + dynamic + app) into a single Vivado project</span>
make<span class="w"> </span>link

<span class="c1"># Place and route the linked shell (all three layers)</span>
make<span class="w"> </span>shell

<span class="c1"># Compile the application layer (only if EN_PR is enabled)</span>
make<span class="w"> </span>app

<span class="c1"># Generate bitstreams</span>
make<span class="w"> </span>bitgen
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">EN_PR</span> <span class="pre">=</span> <span class="pre">1</span></code> floor-planning of the applications (vFPGAs) needs to be done by users explicitly after the <em>make shell</em> step.
This can be done by opening the generated <code class="docutils literal notranslate"><span class="pre">shell_subdivided.dcp</span></code> checkpoint.
Check out the following link for a detailed <a class="reference external" href="https://docs.amd.com/r/en-US/ug903-vivado-using-constraints/Floorplanning">floor-planning guide</a>.
Alternatively, users can provide pre-existing vFPGA floor-plan via the <code class="docutils literal notranslate"><span class="pre">FPLAN_PATH</span></code> variable during configuration.</p>
<p>Once the (typically quite lengthy) compilation is done, the bitstreams will be generated for each application and configuration.
The shell bitstream (<em>the dynamic layer bitstream</em>) with the initial (config 0) configuration will also be generated.
This one can be used to load the shell dynamically and swap out other shells during runtime.
All of these will be present in the <cite>bitstreams</cite> directory.</p>
<figure class="align-default" id="build-struct">
<img alt="../_images/build_struct.png" src="../_images/build_struct.png" />
</figure>
<p>The overall bitstream structure should roughly resemble the one in the figure above.</p>
</section>
</section>
<section id="building-the-driver">
<h2>Building the driver<a class="headerlink" href="#building-the-driver" title="Link to this heading"></a></h2>
<p>The driver can be built by running make within the driver directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>driver<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure to compile the driver on the target deployment machine.</p>
</div>
</section>
<section id="building-the-software">
<h2>Building the software<a class="headerlink" href="#building-the-software" title="Link to this heading"></a></h2>
<p>Procedure to build the software is similar to the one for hardware, albeit more simple.
Again, software build use CMake for compiling the software. For examples of CMakeLists.txt for software builds, refer to <strong>Coyote/examples</strong>.</p>
<p>The steps remain the same as for the hardware build:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>build_sw<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_sw
cmake<span class="w"> </span>&lt;path-to-cmake-config&gt;<span class="w"> </span>&lt;additional-flags&gt;
make
</pre></div>
</div>
</section>
<section id="deploying-coyote">
<h2>Deploying Coyote<a class="headerlink" href="#deploying-coyote" title="Link to this heading"></a></h2>
<p>We cover how to deploy the examples in two set-ups: The Heterogeneous Accelerated Compute Cluster (HACC) at ETH Zurich and on a independent set-up.</p>
<section id="eth-hacc">
<h3>ETH HACC<a class="headerlink" href="#eth-hacc" title="Link to this heading"></a></h3>
<p>The Heterogeneous Accelerated Compute Clusters (HACC) program is a special initiative to support novel research in adaptive compute acceleration.
The scope of the program is broad and encompasses systems, architecture, tools and applications.
You can check out HACC in more details at: <a class="reference external" href="https://www.amd-haccs.io/">amd-haccs</a>.</p>
<p>The ETH HACC provides the ideal environment to run Coyote examples,
since users can book various compute nodes (Alveo U55C, V80, U250, U280, Instinct GPU etc.)
which are connected via a high-speed (100G) network.</p>
<figure class="align-default">
<img alt="../_images/hacc.png" src="../_images/hacc.png" />
</figure>
<p>The interaction and deployment of Coyote on the HACC cluster can be simplified by using the <code class="docutils literal notranslate"><span class="pre">hdev</span></code> tool.
It also allows to easily program the FPGA with a Coyote bitstream and insert the driver.
For this purpose, the script <code class="docutils literal notranslate"><span class="pre">util/program_hacc_local.sh</span></code> has been created:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>bash<span class="w"> </span>util/program_hacc_local.sh<span class="w"> </span>&lt;path-to-bitstream&gt;<span class="w"> </span>&lt;path-to-driver-ko&gt;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bitstreams with <code class="docutils literal notranslate"><span class="pre">.bin</span></code> extensions should be used when loading the designs dynamically through Coyote. If bitstreams are being programmed through Vivado programmer, use the ones with <code class="docutils literal notranslate"><span class="pre">.bit</span></code> extension.</p>
</div>
<p>A successful completion of the FPGA programming and driver insertion can be checked via a call to:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>dmesg
</pre></div>
</div>
<p>If the driver insertion and bitstream programming went correctly through, the last printed message should be <code class="docutils literal notranslate"><span class="pre">probe</span> <span class="pre">returning</span> <span class="pre">0</span></code>.
If you see this, your system is all ready to run the accompanying Coyote software.</p>
</section>
<section id="independent-set-up">
<h3>Independent set-up<a class="headerlink" href="#independent-set-up" title="Link to this heading"></a></h3>
<p>The steps to follow when deploying Coyote on an independent set-up are:</p>
<ol class="arabic simple">
<li><p>Program the FPGA using the synthesized bitstream using Vivado Hardware Manager via the GUI or a custom script.</p></li>
<li><p>Rescan the PCIe devices and run PCI hot-plug.</p></li>
<li><p>Insert the driver using (the parameters IP and MAC must only be specified when using networking on the FPGA):</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>sudo<span class="w"> </span>insmod<span class="w"> </span>Coyote/driver/coyote_driver.ko<span class="w"> </span><span class="nv">ip_addr</span><span class="o">=</span><span class="nv">$qsfp_ip</span><span class="w"> </span><span class="nv">mac_addr</span><span class="o">=</span><span class="nv">$qsfp_mac</span><span class="w"> </span><span class="o">(</span><span class="p">;</span><span class="w"> </span>i.e.<span class="w"> </span>Example<span class="w"> </span><span class="m">8</span><span class="o">)</span>
</pre></div>
</div>
<p>A successful completion of the FPGA programming and driver insertion can be checked via a call to:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>dmesg
</pre></div>
</div>
<p>If the driver insertion and bitstream programming went correctly through, the last printed message should be <code class="docutils literal notranslate"><span class="pre">probe</span> <span class="pre">returning</span> <span class="pre">0</span></code>.
If you see this, your system is all ready to run the accompanying Coyote software.</p>
<p>Coyote has been successfully deployed on other FPGA clusters (e.g., in the <a class="reference external" href="https://octestbed.org/">Open Cloud Testbed</a>) and independent set-ups.
For some ideas of projects that were based on Coyote, check out the <a class="reference internal" href="publications.html#publications"><span class="std std-ref">Citation and publications</span></a> page.</p>
</section>
</section>
<section id="simulating-vfpgas">
<h2>Simulating vFPGAs<a class="headerlink" href="#simulating-vfpgas" title="Link to this heading"></a></h2>
<p>A more comprehensive documentation for the simulation environment can be found at <code class="docutils literal notranslate"><span class="pre">sim/README.md</span></code>.
To get started with the simulation target for the software library, execute <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">sim</span></code> after initializing the hardware build directory with <code class="docutils literal notranslate"><span class="pre">cmake</span></code> and add the SIM_DIR flag to the <code class="docutils literal notranslate"><span class="pre">cmake</span></code> call of the software build directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake<span class="w"> </span>&lt;CMakeLists.txt_location&gt;<span class="w"> </span>-DSIM_DIR<span class="o">=</span>&lt;sim_build_dir&gt;...
</pre></div>
</div>
<p>After building the software with <code class="docutils literal notranslate"><span class="pre">make</span></code>, the binary may be executed the same as if a programmed FPGA was available.
It will automatically start Vivado in the background and start the testbench environment to simulate the vFPGA.</p>
<p>Besides this simulation target for the Coyote C++ library, a Python unit test framework is available that is documented in detail in <code class="docutils literal notranslate"><span class="pre">sim/unit-test/README.md</span></code>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="Features" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="faq.html" class="btn btn-neutral float-right" title="Frequently asked questions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, System Group, ETH Zurich.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>