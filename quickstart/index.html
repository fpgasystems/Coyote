

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Coyote Quick Start &mdash; Coyote-docs v0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=683873e3"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="HACC Cluster" href="../hacc/index.html" />
    <link rel="prev" title="Welcome to Coyote’s documentation!" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Coyote-docs
              <img src="../_static/cyt_logo_dark.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Quick Start</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Coyote Quick Start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-and-loading-the-hardware">Building and Loading the Hardware</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hardware-configuration">Hardware Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#project-structure">Project Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#builds">Builds</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linking-additional-projects-to-the-existing-shell">Linking Additional Projects to the Existing Shell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-the-bitstreams">Loading the bitstreams</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hot-plug">Hot Plug</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-and-loading-the-driver">Building and Loading the Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-insertion">Driver Insertion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exposed-vfpga-devices">Exposed vFPGA Devices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-the-software">Building the Software</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#running-coyote-as-a-service">Running Coyote as a Service</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#shell-loading">Shell Loading</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deploying Coyote in HACC</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hacc/index.html">HACC Cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hacc/index.html#sgrt-systems-group-runtime">SGRT - Systems Group RunTime</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">System Architecture</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../system/static/index.html">Static Layer of the Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/dynamic/index.html">Dynamic Layer of the Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/application/index.html">Application Layer of the Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/vms/index.html">Virtual Machines</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">Developer Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addinfo/index.html">Additional Info</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coyote-docs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Coyote Quick Start</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/quickstart/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="coyote-quick-start">
<h1>Coyote Quick Start<a class="headerlink" href="#coyote-quick-start" title="Link to this heading"></a></h1>
<p>This is a brief introductory section outlining the steps to run <em>Coyote</em> and the essential prerequisites for its setup.</p>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading"></a></h2>
<p>Full Vivado/Vitis suite is needed to build hardware designs. Hardware server will be enough for deployment only scenarios.
Various Ubuntu versions should be supported (we advise on using 20.04).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Coyote runs with <em>Vivado 2022.1</em>. Previous versions can be used at one’s own peril.</p>
</div>
<p>Following AMD data center cards are supported: <code class="docutils literal notranslate"><span class="pre">Alveo</span> <span class="pre">u50</span></code>, <code class="docutils literal notranslate"><span class="pre">Alveo</span> <span class="pre">u55c</span></code>, <code class="docutils literal notranslate"><span class="pre">Alveo</span> <span class="pre">u200</span></code>, <code class="docutils literal notranslate"><span class="pre">Alveo</span> <span class="pre">u250</span></code> and <code class="docutils literal notranslate"><span class="pre">Alveo</span> <span class="pre">u280</span></code>. You can also deploy <em>Coyote</em> on a development board, for example <code class="docutils literal notranslate"><span class="pre">vcu118</span></code>.</p>
<p><em>Coyote</em> has continously been developed on the HACC cluster at ETH Zurich. For more information and possible external access check out the following link:
<a class="reference external" href="https://systems.ethz.ch/research/data-processing-on-modern-hardware/hacc.html">ETH Zurich HACC</a>.</p>
<p><em>CMake</em> is used for project creation (version 3.0+) and builds. Additionally <em>Jinja2</em> template engine for Python is used for some of the code generation.</p>
<p>The API is writen in <em>C++</em>, 17 should suffice (for now).</p>
<p>If networking services are used, to generate the design you will need a valid
<a class="reference external" href="https://www.xilinx.com/products/intellectual-property/cmac_usplus.html">UltraScale+ Integrated 100G Ethernet Subsystem</a> license set up in <cite>Vivado</cite>/<cite>Vitis</cite>.</p>
<p>To run the virtual machines on top of individual <em>vFPGAs</em> the following packages are needed: <em>qemu-kvm</em>, <em>build-essential</em> and <em>kmod</em>.</p>
</section>
<section id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Link to this heading"></a></h2>
<p>You can clone the full <em>Coyote</em> repository if you want to change stuff within the framework.
When cloning the repository be sure to check out all the submodules:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>--recurse-submodules<span class="w"> </span>https://github.com/fpgasystems/Coyote
</pre></div>
</div>
<p>Otherwise, we suggest to use <em>Coyote</em> as a submodule within your projects:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>git<span class="w"> </span>submodule<span class="w"> </span>add<span class="w"> </span>https://github.com/fpgasystems/Coyote
&gt;<span class="w"> </span>git<span class="w"> </span>submodule<span class="w"> </span>update<span class="w"> </span>--init<span class="w"> </span>--recursive
</pre></div>
</div>
<p>An example of how this can be done can be seen in the following repo: <a class="reference external" href="https://systems.ethz.ch/research/data-processing-on-modern-hardware/hacc.html">Coyote-PROJECT</a>.</p>
</section>
<section id="building-and-loading-the-hardware">
<h2>Building and Loading the Hardware<a class="headerlink" href="#building-and-loading-the-hardware" title="Link to this heading"></a></h2>
<p>The <em>CMake</em> is coupled with the <em>project</em> flow within Vivado.
This flow provides the capability to synthesize individual application projects (to be loaded in different <strong>virtual FPGAs</strong>) independently and subsequently merge them into a single overarching project after the synthesis step.</p>
<p>This is the basis for the <strong>nested system layers</strong> exposed by <em>Coyote</em>.
The following sub-layers (each represented by a different <em>Vivado</em> project) exist:</p>
<ol class="arabic">
<li><p><strong>Static Layer</strong> : This is the static portion of the system. It is always the same for every project (for the same chip). It provides the bare essential functionality to support the rest of the system.</p></li>
<li><p><strong>Dynamic (Shell, Service) Layer</strong> : This layer houses all the services offered by <em>Coyote</em> which are shared among all applications. It is the first dynamic layer that can be swapped during runtime and represents the current shell configuration.</p></li>
<li><p><strong>Application Layer</strong> : This layer houses all user projects, each representing a separate user application. The number of overall projects depends on two factors:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>the number of <em>virtual FPGAs</em> (<strong>vFPGAs</strong>) within the dynamic layer (<code class="docutils literal notranslate"><span class="pre">N_REGIONS</span></code>), and</p></li>
<li><p>the number of different configurations of these <strong>vFPGAs</strong> within the overarching shell (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span></code>).</p></li>
</ol>
</div></blockquote>
</li>
</ol>
<section id="hardware-configuration">
<h3>Hardware Configuration<a class="headerlink" href="#hardware-configuration" title="Link to this heading"></a></h3>
<p>The hardware configuration is provided via <em>CMake</em>. The following is an example of a project configuration:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.0</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">example_prj</span><span class="p">)</span>

<span class="nb">set</span><span class="p">(</span><span class="s">CYT_DIR</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="o">}</span><span class="s">/</span><span class="p">)</span><span class="w"> </span><span class="c"># Path to Coyote dir</span>
<span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_MODULE_PATH</span><span class="w"> </span><span class="o">${</span><span class="nv">CMAKE_MODULE_PATH</span><span class="o">}</span><span class="w"> </span><span class="o">${</span><span class="nv">CYT_DIR</span><span class="o">}</span><span class="s">/cmake</span><span class="p">)</span>

<span class="nb">find_package</span><span class="p">(</span><span class="s">CoyoteHW</span><span class="w"> </span><span class="s">REQUIRED</span><span class="p">)</span>

<span class="c"># Shell configuration</span>
<span class="nb">set</span><span class="p">(</span><span class="s">FDEV_NAME</span><span class="w"> </span><span class="s2">&quot;u55c&quot;</span><span class="p">)</span><span class="w"> </span><span class="c"># Link to u55c static</span>
<span class="nb">set</span><span class="p">(</span><span class="s">N_REGIONS</span><span class="w"> </span><span class="s">2</span><span class="p">)</span><span class="w"> </span><span class="c"># Number of vFPGAs in this specific shell</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_PR</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w"> </span><span class="c"># Enable 2nd level dynamic reconfiguration</span>
<span class="nb">set</span><span class="p">(</span><span class="s">N_CONFIG</span><span class="w"> </span><span class="s">2</span><span class="p">)</span><span class="w"> </span><span class="c"># Number of app dynamic configurations</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_STRM</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w"> </span><span class="c"># Interface to host memory</span>
<span class="nb">set</span><span class="p">(</span><span class="s">EN_MEM</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w"> </span><span class="c"># Interface to FPGA-side memory (HBM/DRAM)</span>
<span class="nb">set</span><span class="p">(</span><span class="s">HBM_SPLIT</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w"> </span><span class="c"># Specific HBM configuration</span>

<span class="nb">validation_checks_hw</span><span class="p">()</span><span class="w"> </span><span class="c"># Validate configuration</span>

<span class="nb">load_apps</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="c"># Load arbitrary user applications for all configs</span>
<span class="w">    </span><span class="s">VFPGA_C0_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/addmul&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C0_1</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/cntmin&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C1_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/shifter&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C1_1</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/hloglog&quot;</span>
<span class="p">)</span>

<span class="nb">create_hw</span><span class="p">()</span><span class="w"> </span><span class="c"># Generate all targets</span>
</pre></div>
</div>
<p>This project will link to the existing static design floorplanned for the <em>Alveo u55c</em> chip.</p>
<p>After indicating the path to <em>Coyote</em> repository, the shell configuration is chosen. In the example, we enable two distinct <strong>vFPGAs</strong>.
Each of these functions as an <em>independent hardware process</em>, accommodating one user application (<em>user process</em>) at a time.
Applications in these <strong>vFPGAs</strong> can also be swapped during runtime without disrupting the surrounding shell operations (<code class="docutils literal notranslate"><span class="pre">EN_PR</span></code> flag).
Multiple dynamic configurations can be compiled within one project (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span></code>).
Additional flags can then be provided. All these will define the exact configuration of the shell.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the complete list of the shell configuration options please check <span class="xref std std-ref">Shell Configurations</span>.</p>
</div>
<p>Be sure to include the <code class="docutils literal notranslate"><span class="pre">validation_checks_hw()</span></code> and <code class="docutils literal notranslate"><span class="pre">create_hw()</span></code> functions, necessary for properly setting up the environment.</p>
</section>
<section id="project-structure">
<h3>Project Structure<a class="headerlink" href="#project-structure" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> function facilitates the automatic loading of user hardware applications into the corresponding <strong>vFPGAs</strong>.
This process also performs any essential high-level synthesis compilations, if needed.
When utilized, users must explicitly provide path to all configurations (<code class="docutils literal notranslate"><span class="pre">N_CONFIG</span> <span class="pre">x</span> <span class="pre">N_REGIONS</span></code>).</p>
<p>The hardware applications (in the provided path) should be structured as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>├<span class="w"> </span>&lt;coyote<span class="w"> </span>submodule&gt;
├<span class="w"> </span>CMakeLists.txt<span class="w"> </span><span class="o">(</span>an<span class="w"> </span>example<span class="w"> </span>can<span class="w"> </span>be<span class="w"> </span>the<span class="w"> </span>one<span class="w"> </span>shown<span class="w"> </span>previously<span class="o">)</span>
└<span class="w"> </span>&lt;path_to_your_hw_project&gt;
<span class="w">    </span>├<span class="w"> </span>vfpga_top.svh<span class="w"> </span><span class="o">(</span>this<span class="w"> </span>is<span class="w"> </span>the<span class="w"> </span>integration<span class="w"> </span>wrapper,<span class="w"> </span>connect<span class="w"> </span>your<span class="w"> </span>stuff<span class="w"> </span>to<span class="w"> </span>the<span class="w"> </span>interfaces<span class="o">)</span>
<span class="w">    </span>├<span class="w"> </span>init_ip.tcl<span class="w"> </span><span class="o">(</span>all<span class="w"> </span>extra<span class="w"> </span>IP<span class="w"> </span>cores<span class="w"> </span>can<span class="w"> </span>be<span class="w"> </span>instantiated<span class="w"> </span>here,<span class="w"> </span>buffers,<span class="w"> </span>ILAs,<span class="w"> </span>VIOs<span class="w"> </span>...<span class="o">)</span>
<span class="w">    </span>└<span class="w"> </span>hls<span class="w"> </span><span class="o">(</span>put<span class="w"> </span>all<span class="w"> </span>your<span class="w"> </span>hls<span class="w"> </span>cores<span class="w"> </span>under<span class="w"> </span>this<span class="w"> </span>directory<span class="o">)</span>
<span class="w">        </span>├<span class="w"> </span>kernel_1
<span class="w">            </span>└<span class="w"> </span>kernel_1<span class="w"> </span>files<span class="w"> </span><span class="o">(</span>should<span class="w"> </span>contain<span class="w"> </span>kernel_1.cpp<span class="w"> </span>top<span class="w"> </span>level<span class="o">)</span>
<span class="w">        </span>├<span class="w"> </span>kernel_2
<span class="w">        </span>└<span class="w"> </span>kernel_3
<span class="w">    </span>└<span class="w"> </span>hdl
<span class="w">        </span>└<span class="w"> </span>all<span class="w"> </span>RTL<span class="w"> </span>cores<span class="w"> </span>and<span class="w"> </span>files<span class="w"> </span>that<span class="w"> </span>might<span class="w"> </span>be<span class="w"> </span>used<span class="w"> </span><span class="o">(</span>.v,<span class="w"> </span>.sv,<span class="w"> </span>.svh,<span class="w"> </span>.vhd,<span class="w"> </span>...<span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure to create the <code class="docutils literal notranslate"><span class="pre">vfpga_top.svh</span></code>. This is the main integration header file. It is used to connect your circuits to the interfaces exposed by each <cite>vFPGA</cite>.</p>
</div>
<p>It is not necessary to use the <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> function. You can also integrate your circuits manually into the provided wrappers (available after the project creation step).</p>
</section>
<section id="builds">
<h3>Builds<a class="headerlink" href="#builds" title="Link to this heading"></a></h3>
<p>The projects can be built after configuration and directories have been setup.
First, the build directory can be created:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>mkdir<span class="w"> </span>build_hw<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_hw
</pre></div>
</div>
<p>The <em>CMake</em> configuration can then be invoked:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>cmake<span class="w"> </span>&lt;path_to_cmake_config&gt;<span class="w"> </span>&lt;any_additional_configs_if_needed&gt;
</pre></div>
</div>
<p>If all validation checks pass without errors, all the necessary build files will be generated after this step.
Project creation can be then be invoked with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>make<span class="w"> </span>project
</pre></div>
</div>
<p>This will create all projects:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&lt;project_name&gt;_static<span class="w"> </span><span class="c1"># Only if static region is being generated (BUILD_STATIC = 1)</span>
&lt;project_name&gt;_shell<span class="w">  </span><span class="c1"># This is the dynamic shell</span>
&lt;project_name&gt;_config_0/&lt;project_name&gt;_user_c0_0<span class="w"> </span><span class="c1"># (vFPGA_C0_0)</span>
&lt;project_name&gt;_config_0/&lt;project_name&gt;_user_c0_1<span class="w"> </span><span class="c1"># (vFPGA_C0_1)</span>
...
&lt;project_name&gt;_config_1/&lt;project_name&gt;_user_c1_0<span class="w"> </span><span class="c1"># (vFPGA_C1_0)</span>
...
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">load_apps()</span></code> was used, there is nothing else that users need to do after this command.
Otherwise each of the user projects (<code class="docutils literal notranslate"><span class="pre">vFPGA_CX_Y</span></code>) will contain wrappers under the <em>project/hdl</em> directory where
users can instantiate their circuits as they please.</p>
</section>
<section id="compilation">
<h3>Compilation<a class="headerlink" href="#compilation" title="Link to this heading"></a></h3>
<p>Compilation can then be executed.
To generate all bitstreams straight away, users can run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>make<span class="w"> </span>bitgen
</pre></div>
</div>
<p>The command consists of the following incremental steps:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>make<span class="w"> </span>synth<span class="w"> </span><span class="c1"># Synth all layers</span>
&gt;<span class="w"> </span>make<span class="w"> </span>link<span class="w"> </span><span class="c1"># Link all layers</span>
&gt;<span class="w"> </span>make<span class="w"> </span>shell<span class="w"> </span><span class="c1"># Compile the shell (static + dynamic layers)</span>
&gt;<span class="w"> </span>make<span class="w"> </span>app<span class="w"> </span><span class="c1"># Compile the application layer (only if EN_PR is enabled)</span>
&gt;<span class="w"> </span>make<span class="w"> </span>bitgen<span class="w"> </span><span class="c1"># Generate all bitstreams</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">EN_PR</span></code> floorplanning of the applications (<strong>vFPGAs</strong>) needs to be done by users explicitly after the <em>make shell</em> step.
This can be done by opening the generated <code class="docutils literal notranslate"><span class="pre">shell_subdivided.dcp</span></code> checkpoint.
Check out the following link for the detailed <a class="reference external" href="https://docs.amd.com/r/en-US/ug903-vivado-using-constraints/Floorplanning">floorplanning guide</a>.
Alternatively, users can provide pre-existing <strong>vFPGA</strong> floorplanning via the <code class="docutils literal notranslate"><span class="pre">FPLAN_PATH</span></code> variable during configuration.</p>
<p>Once the (typically quite lengthy) compilation is done, the bitstreams will be generated for each application and configuration.
The shell bitstream (<em>the dynamic layer bitstream</em>) with the initial (config 0) configuration will also be generated.
This one can be used to load the shell dynamically and swap out other shells during runtime.
All of these will be present in the <cite>bitstreams</cite> directory.</p>
<figure class="align-default" id="build-struct">
<img alt="../_images/build_struct.png" src="../_images/build_struct.png" />
</figure>
<p>The overall bitstream structure should roughly resemble the one in the figure above.</p>
</section>
<section id="linking-additional-projects-to-the-existing-shell">
<h3>Linking Additional Projects to the Existing Shell<a class="headerlink" href="#linking-additional-projects-to-the-existing-shell" title="Link to this heading"></a></h3>
<p>One advantage of the <em>nested framework organization</em> is that additional user applications can easily be added to already compiled shells.</p>
<p>For instance, an application in a networking shell with RDMA enabled can easily be added without having to resynthesize the complete shell.</p>
<p>To do this, users can create an additional project and link it against an existing shell project.
An example of <em>CMake</em> configuration in this case is shown below:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Shell configuration</span>
<span class="nb">set</span><span class="p">(</span><span class="s">BUILD_SHELL</span><span class="w"> </span><span class="s">0</span><span class="p">)</span><span class="w"> </span><span class="c"># We are reusing a shell, not building a new one ...</span>
<span class="nb">set</span><span class="p">(</span><span class="s">BUILD_APP</span><span class="w"> </span><span class="s">1</span><span class="p">)</span><span class="w"> </span><span class="c"># App flow, instead of the default shell flow</span>
<span class="nb">set</span><span class="p">(</span><span class="s">N_CONFIG</span><span class="w"> </span><span class="s">2</span><span class="p">)</span><span class="w"> </span><span class="c"># Number of additional configurations to be added</span>
<span class="nb">set</span><span class="p">(</span><span class="s">SHELL_PATH</span><span class="w"> </span><span class="s2">&quot;path_to_the_existing_shell_dir&quot;</span><span class="p">)</span>

<span class="nb">validation_checks_hw</span><span class="p">()</span><span class="w"> </span><span class="c"># Validate configuration</span>

<span class="nb">load_apps</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="c"># Load additional apps</span>
<span class="w">    </span><span class="s">VFPGA_C0_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/aes_cbc&quot;</span>
<span class="w">    </span><span class="s">VFPGA_C1_0</span><span class="w"> </span><span class="s2">&quot;&lt;some_path_to_the_cores&gt;/aes_ecb&quot;</span>
<span class="p">)</span>

<span class="nb">create_hw</span><span class="p">()</span><span class="w"> </span><span class="c"># Generate all targets</span>
</pre></div>
</div>
<p>The rest of compilation flow doesn’t differ from the one already covered.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>make<span class="w"> </span>project
&gt;<span class="w"> </span>make<span class="w"> </span>bitgen
</pre></div>
</div>
<p>After the compilation, additional bitstreams for the newly added applications will be created which can be dynamically swapped within the existing shell.</p>
</section>
<section id="loading-the-bitstreams">
<h3>Loading the bitstreams<a class="headerlink" href="#loading-the-bitstreams" title="Link to this heading"></a></h3>
<p>The initial bitstreams (<em>static layer</em>) can be loaded via JTAG through <em>Vivado’s</em> hardware programmer. The script under <em>/util/program_alveo.tcl</em> can be used for this loading procedure.
All other bitstreams (<em>shell and application bitstreams</em>) are loaded through the <em>Coyote</em> framework and do not require external tools.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bitstreams with <code class="docutils literal notranslate"><span class="pre">.bin</span></code> extensions should be used when loading the designs dynamically through <em>Coyote</em>. If bitstreams are being programmed through <em>Vivado</em> programmer, use the ones with <code class="docutils literal notranslate"><span class="pre">.bit</span></code> extension.</p>
</div>
</section>
<section id="hot-plug">
<h3>Hot Plug<a class="headerlink" href="#hot-plug" title="Link to this heading"></a></h3>
<p>Whenever the static image of Coyote is loaded for the first time the interconnect has to be rescanned.</p>
<p>For this purpose the scripts under <em>/util/flow_alveo.tcl</em> directory can be used. The ETHZ-HACC cluster contains all the necessary infrastructure to automate this for the end users.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rescanning needs to be done only for the initial loading of the static shell. Subsequent shells can be loaded dynamically during runtime.</p>
</div>
</section>
</section>
<section id="building-and-loading-the-driver">
<h2>Building and Loading the Driver<a class="headerlink" href="#building-and-loading-the-driver" title="Link to this heading"></a></h2>
<p>The driver can be built by running make within the driver directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>driver<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be sure to compile the driver on the target deployment machine.</p>
</div>
<section id="driver-insertion">
<h3>Driver Insertion<a class="headerlink" href="#driver-insertion" title="Link to this heading"></a></h3>
<p>After compilation you can insert the driver (make sure to have sudo):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>insmod<span class="w"> </span>coyote_drv.ko<span class="w"> </span>&lt;args&gt;
</pre></div>
</div>
<p>The following arguments can be supplied during driver insertion:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>config_fname</cite></p></td>
<td><p>Configuration file, mapping of devices, used when multiple FPGAs are available.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>cyt_arch</cite></p></td>
<td><p>Target underlining platform. Used to target different interconnects like ECI.</p></td>
</tr>
<tr class="row-even"><td><p><cite>en_hmm</cite></p></td>
<td><p>Enable heterogeneous memory management.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>en_hypervisor</cite></p></td>
<td><p>Run Coyote in hypervisor mode. Used when running VMs on top of vFPGAs.</p></td>
</tr>
<tr class="row-even"><td><p><cite>ip/mac_addr</cite></p></td>
<td><p>IP and MAC addresses for the network stacks.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="exposed-vfpga-devices">
<h3>Exposed vFPGA Devices<a class="headerlink" href="#exposed-vfpga-devices" title="Link to this heading"></a></h3>
<p>Once the driver is inserted a range of device files will be exposed in the kernel under <code class="docutils literal notranslate"><span class="pre">/dev</span></code>.
These can be used from the user space to access the target devices.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>ls<span class="w"> </span>-la<span class="w"> </span>/dev/fpga*
<span class="w">  </span>fpga_0_v0
<span class="w">  </span>fpga_0_v1
<span class="w">  </span>...
<span class="w">  </span>fpga_0_pr
<span class="w">  </span>fpga_1_v0
<span class="w">  </span>...
</pre></div>
</div>
<p>If system contains multiple FPGAs, the first number will indicate the ID of this FPGA.
These IDs can be manually assigned by providing an external <code class="docutils literal notranslate"><span class="pre">config_fname</span></code> file during driver insertion.</p>
<p>The second number after the <cite>v</cite> indicates the target <cite>vFPGA</cite>.
Additinoally, the <cite>pr</cite> device is available which is used by user space scheduler to control the dynamic reconfiguration.</p>
<p>Users can also interact with the system through the <cite>sysfs</cite> file system. Coyote will expose a number of internal registers
which can be read from and writen to in order to control and debug the live system.
These can typically be found under <code class="docutils literal notranslate"><span class="pre">/cat/sys/kernel/coyote_cnfg</span></code>.</p>
</section>
</section>
<section id="building-the-software">
<h2>Building the Software<a class="headerlink" href="#building-the-software" title="Link to this heading"></a></h2>
<p>Procedure to build the software is similar to the one for hardware, albeit more simple.</p>
<p>First create a build directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>mkdir<span class="w"> </span>build_sw<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_sw
</pre></div>
</div>
<p>Then set the <code class="docutils literal notranslate"><span class="pre">TARGET_DIR</span></code> in <cite>CMake</cite> which points to the main sources:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="err">&gt;</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="s">TARGET_DIR</span><span class="w"> </span><span class="s2">&quot;${CYT_DIR}/&lt;some_path_to_sources&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Additional header files can be included in the path under <code class="docutils literal notranslate"><span class="pre">include</span></code>. After that you can just run make:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;<span class="w"> </span>make
</pre></div>
</div>
<section id="running-coyote-as-a-service">
<h3>Running Coyote as a Service<a class="headerlink" href="#running-coyote-as-a-service" title="Link to this heading"></a></h3>
<p>Coyote can also be deployed as a background daemon. Check out the example to see how this can be invoked.</p>
<p>Communication with the daemon is done through either the Unix domain sockets or through TCP sockets for local and remote services, respectively.</p>
</section>
</section>
<section id="shell-loading">
<h2>Shell Loading<a class="headerlink" href="#shell-loading" title="Link to this heading"></a></h2>
<p>User shells (different versions of the dynamic layer) can be loaded at any point as long as the common static layer is on-line.</p>
<p>These can be loaded via the provided examples software application (<code class="docutils literal notranslate"><span class="pre">examples_sw/apps/reconfigure_shell</span></code>).
Users can also load shells dynamically from within their code via the <code class="docutils literal notranslate"><span class="pre">cRnfg`</span></code> class.</p>
<p>Similarly applications in the app layer can be loaded via the same class, but additionally the loading can also be
controlled by the derived <code class="docutils literal notranslate"><span class="pre">cSched</span></code> class which can additionally handle the necessary scheduling.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="Welcome to Coyote’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../hacc/index.html" class="btn btn-neutral float-right" title="HACC Cluster" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Dario Korolija.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>